# Тестовое Задание по Android
## *Цель*:
создать андроид-приложение для поиска работы
## *Требования*:
## 1) Использовать принципы `Clean Architecture`
> Принципы чистой архитектуры также помогают избежать проблем с зависимостями и разделить приложение на логические блоки. Это повышает удобство добавления новых функций и изменения уже существующих. В результате, время разработки сокращается, а приложение становится более гибким и масштабируемым.
## 2) Использовать структурный паттерн `MVVM`
Данный паттерн состоит из трех основных частей: `View`, `Model`, `ViewModel`. 
1) **View**. За весь пользовательский интерфейс отвечает View. К нему можно отнести весь `@Composable` код, или файлы **.XML**, а так же взаимодействия пользователя с экраном и отрисовка всего, что происходит на экране
2) **Model**. Модель отвечает за работу с внешними или внутренними данными, например подключение к серверу, к базе данных или к локальному хранилищу.
3) **ViewModel**. ViewModel - это связующее звено между View и Model. Поскольку во View присутствует ТОЛЬКО UI-логика, то все рассчеты и бизнес-методы реализуются во ViewModel, так же, задача ViewModel - парсить данные, полученные с Model и хранить *Стейты*
## 3) Использовать фреймворк Dagger
Dagger - фреймворк для внедрения зависимостей. Это означает, что когда нам нужно создать много различных объектов, зависящих друг от друга, больше не надо писать гигантский код с созданием одноразовых, ненужных ссылок. Вместо этого обявляется `AppComponent` - граф-резолвер для всех зависимостей. А чтобы их рассчитать, существует много способов, например `@Provides` методы в классе Модуль, или `@Inject` конструктор, или `@BindInstance` для конкретного экземпляра, добавляемого в граф извне. так же существуют более сложные вещи, такие как квалификаторы, `ElementsIntoSet`, `Subcomponents` и другое.
## 4) Использовать язык Kotlin.
Что касается Kotlin, это невероятно мощный язык, полностью совместимый с Java, но имеющий ряд преимуществ, такие как огромное количество синтаксического сахара, совместимость с функциональным программированием. Например в Kotlin есть scope functions(`Run`, `Let`, `Apply`, `Also`, `With`) - с их помощью можно не сохранять ссылку на объект, а сразу прокинуть ее в исполняемую лямбду, которая является функцией высшего порядка. Засчет этого моэно писать бесконечно длинные однострочники и не путаться. Еще есть *non-local* returns, возможные благодаря inline. А так же стоит упомянуть про оператор делегирования `by`. С его помощью можно представить весь объект лишь одной его переменной, изменение или чтение которой будет ссылаться на объект.
