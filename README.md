# Тестовое Задание по Android
## *Цель*:
создать андроид-приложение для поиска работы
## *Требования*:
### 1) Использовать принципы `Clean Architecture`
> Принципы чистой архитектуры также помогают избежать проблем с зависимостями и разделить приложение на логические блоки. Это повышает удобство добавления новых функций и изменения уже существующих. В результате, время разработки сокращается, а приложение становится более гибким и масштабируемым.
### 2) Использовать структурный паттерн `MVVM`
Данный паттерн состоит из трех основных частей: `View`, `Model`, `ViewModel`. 
1) **View**. За весь пользовательский интерфейс отвечает View. К нему можно отнести весь `@Composable` код, или файлы **.XML**, а так же взаимодействия пользователя с экраном и отрисовка всего, что происходит на экране
2) **Model**. Модель отвечает за работу с внешними или внутренними данными, например подключение к серверу, к базе данных или к локальному хранилищу.
3) **ViewModel**. ViewModel - это связующее звено между View и Model. Поскольку во View присутствует ТОЛЬКО UI-логика, то все рассчеты и бизнес-методы реализуются во ViewModel, так же, задача ViewModel - парсить данные, полученные с Model и хранить *Стейты*
### 3) Использовать фреймворк Dagger
Dagger - фреймворк для внедрения зависимостей. Это означает, что когда нам нужно создать много различных объектов, зависящих друг от друга, больше не надо писать гигантский код с созданием одноразовых, ненужных ссылок. Вместо этого обявляется `AppComponent` - граф-резолвер для всех зависимостей. А чтобы их рассчитать, существует много способов, например `@Provides` методы в классе Модуль, или `@Inject` конструктор, или `@BindInstance` для конкретного экземпляра, добавляемого в граф извне. так же существуют более сложные вещи, такие как квалификаторы, `ElementsIntoSet`, `Subcomponents` и другое.
### 4) Использовать язык Kotlin.
Что касается Kotlin, это невероятно мощный язык, полностью совместимый с Java, но имеющий ряд преимуществ, такие как огромное количество синтаксического сахара, совместимость с функциональным программированием. Например в Kotlin есть scope functions(`Run`, `Let`, `Apply`, `Also`, `With`) - с их помощью можно не сохранять ссылку на объект, а сразу прокинуть ее в исполняемую лямбду, которая является функцией высшего порядка. Засчет этого моэно писать бесконечно длинные однострочники и не путаться. Еще есть *non-local* returns, возможные благодаря inline. А так же стоит упомянуть про оператор делегирования `by`. С его помощью можно представить весь объект лишь одной его переменной, изменение или чтение которой будет ссылаться на объект.
### 4) Использовать библиотеку Retrofit
Retrofit - удобная библиотека для работы с REST-сервером. благодаря аннотациям очень легко создавать запросы к серверу, и получать ответ в виде уже распарсенного JSON, а именно сразу объекты.
### 5) Использовать Room
Room - локальная база данных, с которой легко работать и получать данные. К тому же есть крутая фича, а именно получить в результате Select запроса не САМИ ДАННЫЕ, а flow/liveData с ними(в случае изменения данных Room сам будет вызывать `stateFlow.emit()` с новыми данными). В итоге нам не нужно после каждого изменения вызывать метод `update`, а просто достаточно запустить корутину во ViewModel, в которой вызвать `flow.collect()`, и уже тут вычислять и изменять стейты.
### 6) Использовать Корутины
Корутины в Kotlin - замена многопоточности, есть 2 принципа - Structured Concurrency и Cooperative Cancellation. С их помощью запущенные корутины(аналог потока) создают древовидную структуру, где родитель ждет всех детей, а в случае отмены отменяется вся ветка.

##Скриншоты:

![изображение](https://github.com/user-attachments/assets/bd150bbd-459c-45da-b9c4-ca6f4baf4ef3)
![изображение](https://github.com/user-attachments/assets/5a4e8ea4-6440-44de-9397-bba920c4ebaa)
![изображение](https://github.com/user-attachments/assets/d8b98413-54d1-4bd2-b3e2-fe1087ade9e8)
![изображение](https://github.com/user-attachments/assets/c0cb64c0-bb06-461c-9b87-aa1654fdb985)
![изображение](https://github.com/user-attachments/assets/98a19d2a-6a42-4a60-9e85-b371086d584b)
![изображение](https://github.com/user-attachments/assets/f6042a64-9321-4a12-a65d-7fb784fa8d8b)
![изображение](https://github.com/user-attachments/assets/8e3cfebe-793e-4d27-b578-c12d5f3c0e2f)

